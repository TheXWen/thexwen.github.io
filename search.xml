<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常见Java面试题(一)</title>
    <url>/2020/05/10/%E5%B8%B8%E8%A7%81Java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="面向对象的特征有哪些"><a href="#面向对象的特征有哪些" class="headerlink" title="面向对象的特征有哪些"></a>面向对象的特征有哪些</h2><p>面向对象有四大基本特征:封装、抽象、继承、多态</p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类。 就是把现实生活中的对象，抽象为类。</p>
<a id="more"></a>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装就是将对象封装成一个高度自治和相对封闭的个体，对象属性由这个对象自己的方法来读取和改变。<br>如：一个人，他的姓名等属性，要有自己提供的get和set的方法来操作。private naame setName getNme </p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。接口的多种不同的实现方式就是多态。</p>
<h2 id="有了基本数据类型，为什么还需要包装类型"><a href="#有了基本数据类型，为什么还需要包装类型" class="headerlink" title="有了基本数据类型，为什么还需要包装类型"></a>有了基本数据类型，为什么还需要包装类型</h2><p>Java是一个面相对象的编程语言，而基本数据类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<h2 id="“-”和equals有什么区别"><a href="#“-”和equals有什么区别" class="headerlink" title="“==”和equals有什么区别"></a>“==”和equals有什么区别</h2><p>首先数据的表示有基本类型和引用类型。<br>==   基本类型比较值是否相同<br>　　 引用类型比较的是地址是否相同<br>equals()<br>　　只能比较引用类型，默认情况下比较的是地址值是否相同。<br>    但在一些类中重写了这个方法，如包装类,String,Date等，equals()比较的是两个变量的值。</p>
<h2 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h2><p>1.String是内容不可变的字符串。String底层使用了一个不可变的字符数组(final char[])<br>而StringBuillder StringBuffer,是内容可以改变的字符串。StringBuillder StringBuffer底层使用的可变的字符数组（没有使用final来修饰）<br>2.最经典就是拼接字符串。<br>String进行拼接.<code>String str = &quot;a&quot; + &quot;b&quot;;</code><br>StringBuilder或者StringBuffer<br><code>StringBuilder sb = new StringBuilder(); sb.apend(&quot;a&quot;).apend(&quot;b&quot;)</code><br>拼接字符串不能使用String进行拼接，要使用StringBuilder或者StringBuffer<br>3.StringBuilder是线程不安全的，效率较高.而StringBuffer是线程安全的，效率较低。</p>
<h2 id="Java中的集合"><a href="#Java中的集合" class="headerlink" title="Java中的集合"></a>Java中的集合</h2><p>Java中的集合分为value，key–vale(Conllection Map)两种。<br>存储值的有List和Set<br>List是有序的，可以重复的。<br>Set是无序的，不可以重复的。根据equals和hashcode判断，也就是如果一个对象要存储在Set中，必须重写equals和hashCode方法。<br>存储key-value的有map.</p>
<h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><p>ArrayList底层使用时数组。LinkedList使用的是链表<br>数组查询具有查询特定元素比较快。而插入、删除和修改比较慢(数组在内存中是一块连续的内存，如果插入或删除是需要移动内存)。 链表不要求内存是连续的，在当前元素中存放下一个或上一个元素的地址。查询时需要从头部开始，一个一个的找。所以查询效率低。插入时不需要移动内存，只需改变引用指向即可。所以插入或者删除的效率高。<br>ArrayList使用在查询比较多，但是插入和删除比较少的情况，而LinkedList使用在查询比较少而插入和删除比较多的情况。</p>
<h2 id="HashMap、HashTable、ConcurrentHashMap的区别"><a href="#HashMap、HashTable、ConcurrentHashMap的区别" class="headerlink" title="HashMap、HashTable、ConcurrentHashMap的区别"></a>HashMap、HashTable、ConcurrentHashMap的区别</h2><p>HashMap的实现原理<br>HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体. HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据 hash 算法来决定其在数组中的存储位置，在根据 equals 方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry 时，也会根据 hash 算法找到其在数组中的存储位置，再根据 equals 方法从该位置上的链表中取出该Entry。<br>相同点：HashMap和HasheTalbe都可以使用来存储key–value的数据。<br>区别：<br>1、HashMap是可以把null作为key或者value的，而HashTable是不可以的。<br>2、HashMap是线程不安全的，效率较高。而HashTalbe是线程安全的，效率较低。<br>ConcurrentHashMap通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升。</p>
<h2 id="哈希冲突怎么解决"><a href="#哈希冲突怎么解决" class="headerlink" title="哈希冲突怎么解决"></a>哈希冲突怎么解决</h2><p>开放定址法<br>这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。</p>
<h2 id="Java线程的6种状态"><a href="#Java线程的6种状态" class="headerlink" title="Java线程的6种状态"></a>Java线程的6种状态</h2><ol>
<li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li>
<li>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li>
<li>阻塞(BLOCKED)：表示线程阻塞于锁。</li>
<li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</li>
<li>终止(TERMINATED)：表示该线程已经执行完毕。</li>
</ol>
<h2 id="线程池参数详解"><a href="#线程池参数详解" class="headerlink" title="线程池参数详解"></a>线程池参数详解</h2><p>corePoolSize：核心线程池数量<br>在线程数少于核心数量时，有新任务进来就新建一个线程，即使有的线程没事干<br>等超出核心数量后，就不会新建线程了，空闲的线程就得去任务队列里取任务执行了<br>maximumPoolSize：最大线程数量<br>包括核心线程池数量 + 核心以外的数量<br>如果任务队列满了，并且池中线程数小于最大线程数，会再创建新的线程执行任务<br>keepAliveTime：线程超时时间。<br>如果给线程池设置 allowCoreThreadTimeOut(true)，则核心线程在空闲时头上也会响起死亡的倒计时<br>如果任务是多而容易执行的，可以调大这个参数，那样线程就可以在存活的时间里有更大可能接受新任务<br>workQueue：任务队列<br>不同的任务类型有不同的选择，下一小节介绍<br>threadFactory：线程工厂。线程池利用该工厂创建线程。<br>可以给线程起个好听的名字，设置个优先级啥的<br>handler：线程任务拒绝策略<br>CallerRunsPolicy：只要线程池没关闭，就直接用调用者所在线程来运行任务<br>AbortPolicy：直接抛出 RejectedExecutionException 异常<br>DiscardPolicy：悄悄把任务放生，不做了<br>DiscardOldestPolicy：把队列里待最久的那个任务扔了，然后再调用 execute() 试试看能行不<br>我们也可以实现自己的 RejectedExecutionHandler 接口自定义策略，比如如记录日志什么的</p>
<h2 id="线程的几种实现方式"><a href="#线程的几种实现方式" class="headerlink" title="线程的几种实现方式"></a>线程的几种实现方式</h2><p>1、通过继承Thread（斯ruai德）类实现一个线程<br>2、通过实现Runnable接口实现一个线程<br>   继承扩展性不强，java总只支持单继承，如果一个类继承Thread就不能继承其他的类了。</p>
<h2 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h2><p>1、限定线程的个数，不会导致由于线程过多导致系统运行缓慢或崩溃<br>2、线程池不需要每次都去创建或销毁，节约了资源、<br>3、线程池不需要每次都去创建，响应时间更快。</p>
<h2 id="常用的设计模式有哪些"><a href="#常用的设计模式有哪些" class="headerlink" title="常用的设计模式有哪些"></a>常用的设计模式有哪些</h2><p>单例(懒汉模式、饿汉模式)<br>1、构造方法私有化，除了自己类中能创建外其他地方都不能创建<br>2、在自己的类中创建一个单实例（饿汉模式是类加载就创建单实例，而懒汉模式是第一次被使用的时候才创建）<br>3、提供一个方法获取该实例对象(创建时需要进行方法同步)<br>工厂模式:Spring IOC就是使用了工厂模式.对象的创建交给一个工厂去创建。<br>代理模式:Spring AOP就是使用的动态代理。</p>
<h2 id="Synchronized修饰静态方法和非静态方法有什么区别"><a href="#Synchronized修饰静态方法和非静态方法有什么区别" class="headerlink" title="Synchronized修饰静态方法和非静态方法有什么区别"></a>Synchronized修饰静态方法和非静态方法有什么区别</h2><p>修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。<br>修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。</p>
<h2 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h2><p>两者的共同点：<br>可重入，同一线程可以多次获得同一个锁<br>两者的不同点：<br>ReentrantLock手动开启、释放锁，synchronized隐式开启释放锁<br>ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性<br>ReentrantLock 依赖于 API，而synchronized依赖于JVM<br>ReentrantLock可以实现公平锁<br>ReentrantLock通过Condition可以绑定多个条件</p>
<h2 id="Java多线程公平锁与非公平锁"><a href="#Java多线程公平锁与非公平锁" class="headerlink" title="Java多线程公平锁与非公平锁"></a>Java多线程公平锁与非公平锁</h2><p>公平锁：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得<br>非公平锁：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p>
<h2 id="Java可重入锁与不可重入锁"><a href="#Java可重入锁与不可重入锁" class="headerlink" title="Java可重入锁与不可重入锁"></a>Java可重入锁与不可重入锁</h2><p>所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁</p>
<h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁<br>乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。</p>
<p>##数据库事务隔离级别<br>| 隔离级别  | 脏读  | 不可重复读  | 幻读  |<br>| :————: | :————: | :————: | :————: |<br>| 读未提交  | 可能  | 可能  |  可能 |<br>|  读已提交 | 不可能  | 可能  |  可能 |<br>| 可重复读  | 不可能  | 不可能  | 可能|<br>| 可串行化  | 不可能  | 不可能  | 不可能|<br>读未提交：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据<br>读已提交：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)<br>可重复读：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读<br>串行读：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</p>
<p>1.脏读: 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。<br>2.不可重复读:是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读<br>3.幻读:第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p>
<h2 id="MySQL索引类型"><a href="#MySQL索引类型" class="headerlink" title="MySQL索引类型"></a>MySQL索引类型</h2><p> B+Tree、哈希索引、R-Tree、全文索引</p>
<h2 id="B-Tree相对于B-Tree有几点不同"><a href="#B-Tree相对于B-Tree有几点不同" class="headerlink" title="B+Tree相对于B-Tree有几点不同"></a>B+Tree相对于B-Tree有几点不同</h2><p>1.非叶子节点是叶子节点的索引<br>2.要存储的数据都存放在叶子节点中<br>3.叶子节点之间都有一个链指针，不需要遍历整棵树就可以得到所存储的全部数据</p>
<h2 id="MySQL执行引擎有哪些"><a href="#MySQL执行引擎有哪些" class="headerlink" title="MySQL执行引擎有哪些"></a>MySQL执行引擎有哪些</h2><p>InnoDB、MyIsam</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>
<h2 id="排序算法有那些"><a href="#排序算法有那些" class="headerlink" title="排序算法有那些"></a>排序算法有那些</h2><p>选择排序、插入排序、冒泡排序、希尔排序、归并排序、快速排序、堆排序、基数排序、桶排序</p>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>200 - 请求成功<br>301 - 资源（网页等）被永久转移到其它URL<br>302 - 重定向<br>404 - 请求的资源（网页等）不存在<br>500 - 内部服务器错误</p>
<h2 id="Session的两种实现方式"><a href="#Session的两种实现方式" class="headerlink" title="Session的两种实现方式"></a>Session的两种实现方式</h2><p>1.通过cookie<br>创建Session的时候，服务器将生成一个唯一的sessionid然后用它生成一个关闭浏览器就会失效的cookie。<br>2.url重写<br>通过cookie可以很好地实现session，但是如果客户端由于某些原因（比如出于安全考虑）而禁用cookie，在这种情况之下，为了使session能够继续生效，可以采用url重写。</p>
<h2 id="如何解决负载均衡之后的session共享问题"><a href="#如何解决负载均衡之后的session共享问题" class="headerlink" title="如何解决负载均衡之后的session共享问题"></a>如何解决负载均衡之后的session共享问题</h2><p>1.不使用session，换作cookie<br>2.数据库记录下session信息<br>4.对session文件进行同步。</p>
<h2 id="Mybatis一级缓存、二级缓存"><a href="#Mybatis一级缓存、二级缓存" class="headerlink" title="Mybatis一级缓存、二级缓存"></a>Mybatis一级缓存、二级缓存</h2><p>一级缓存是SqlSession级别的缓存，放在session里面，在对象中有一个数据结构（HashMap）用于存储缓存数据。<br>二级缓存是mapper级别的缓存，放在它的命名空间里</p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Centeos7 Docker 打开zookeeper查看入驻服务信息</title>
    <url>/2020/04/12/Centeos7-Docker-%E6%89%93%E5%BC%80zookeeper%E6%9F%A5%E7%9C%8B%E5%85%A5%E9%A9%BB%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-启动Docker"><a href="#1-启动Docker" class="headerlink" title="1.启动Docker"></a>1.启动Docker</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h2 id="2-查看zookeeper进程"><a href="#2-查看zookeeper进程" class="headerlink" title="2.查看zookeeper进程"></a>2.查看zookeeper进程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="/2020/04/12/Centeos7-Docker-%E6%89%93%E5%BC%80zookeeper%E6%9F%A5%E7%9C%8B%E5%85%A5%E9%A9%BB%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF/viewProgress.JPG" alt="查看zookeeper进程"></p>
<h2 id="3-进入zkCli-sh"><a href="#3-进入zkCli-sh" class="headerlink" title="3.进入zkCli.sh"></a>3.进入zkCli.sh</h2><p>依次输入以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it abdc037e339e &#x2F;bin&#x2F;bash</span><br><span class="line">ls</span><br><span class="line">cd bin</span><br><span class="line">ls</span><br><span class="line">.&#x2F;zkCli.sh</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/12/Centeos7-Docker-%E6%89%93%E5%BC%80zookeeper%E6%9F%A5%E7%9C%8B%E5%85%A5%E9%A9%BB%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF/enter.JPG" alt="进入zkCli.sh"></p>
<h2 id="4-服务注册之后ls-会出现services"><a href="#4-服务注册之后ls-会出现services" class="headerlink" title="4.服务注册之后ls /会出现services"></a>4.服务注册之后ls /会出现services</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &#x2F;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/12/Centeos7-Docker-%E6%89%93%E5%BC%80zookeeper%E6%9F%A5%E7%9C%8B%E5%85%A5%E9%A9%BB%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF/ls.JPG" alt="服务注册之后ls"></p>
<h2 id="5-列出services所有服务"><a href="#5-列出services所有服务" class="headerlink" title="5.列出services所有服务"></a>5.列出services所有服务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &#x2F;services</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/12/Centeos7-Docker-%E6%89%93%E5%BC%80zookeeper%E6%9F%A5%E7%9C%8B%E5%85%A5%E9%A9%BB%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF/services.JPG" alt="列出services所有服务"></p>
<h2 id="6-退出zkCli-sh"><a href="#6-退出zkCli-sh" class="headerlink" title="6.退出zkCli.sh"></a>6.退出zkCli.sh</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>以上就是Centeos7 Docker 打开zookeeper查看入驻服务信息的流程</p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot使用阿里云OSS实现图片上传</title>
    <url>/2020/03/31/Spring-Boot%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-在Maven项目中加入依赖项"><a href="#1-在Maven项目中加入依赖项" class="headerlink" title="1.在Maven项目中加入依赖项"></a>1.在Maven项目中加入依赖项</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-获取AccessKey"><a href="#2-获取AccessKey" class="headerlink" title="2.获取AccessKey"></a>2.获取AccessKey</h2><p>登录阿里云，在个人头像下面有一个AccessKey管理选项，点击进入创建一个AccessKey</p>
<a id="more"></a>
<p><img src="/2020/03/31/Spring-Boot%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/AccessKey.JPG" alt="创建AccessKey"></p>
<h2 id="3-创建一个Bucket"><a href="#3-创建一个Bucket" class="headerlink" title="3.创建一个Bucket"></a>3.创建一个Bucket</h2><p>在阿里云的对象存储创建一个Bucket</p>
<h2 id="4-编写上传类"><a href="#4-编写上传类" class="headerlink" title="4.编写上传类"></a>4.编写上传类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String AccessKeyID;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">private</span> String AccessKeySecret;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(InputStream fileStream, String fileName)</span></span>&#123; <span class="comment">//fileStream:文件流 fileName:文件名</span></span><br><span class="line">        String endpoint = <span class="string">""</span>; <span class="comment">//根据自己的地域填写</span></span><br><span class="line">        String accessKeyId = AccessKeyID;</span><br><span class="line">        String accessKeySecret = AccessKeySecret;</span><br><span class="line">        String bucketName = <span class="string">""</span>; <span class="comment">//根据自己的bucketName填写</span></span><br><span class="line">		<span class="comment">//随机生成文件名</span></span><br><span class="line">        String generatedFileName = <span class="string">""</span>;</span><br><span class="line">        String[] filePaths = fileName.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">if</span> (filePaths.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            generatedFileName = UUID.randomUUID().toString() + <span class="string">"."</span> + filePaths[filePaths.length - <span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">        OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建存储空间。</span></span><br><span class="line">        ossClient.createBucket(bucketName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上传文件流。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ossClient.putObject(bucketName, generatedFileName, fileStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭OSSClient。</span></span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">        <span class="keyword">return</span> generatedFileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上，就是阿里云OSS实现图片上传的流程</p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>OSS</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>调用Gitee/Github API实现第三方登录流程</title>
    <url>/2020/03/24/%E8%B0%83%E7%94%A8Gitee-Github-API%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-创建一个Gitee-Github第三方应用"><a href="#1-创建一个Gitee-Github第三方应用" class="headerlink" title="1.创建一个Gitee/Github第三方应用"></a>1.创建一个Gitee/Github第三方应用</h2><p>这里以Gitee为例<br><img src="/2020/03/24/%E8%B0%83%E7%94%A8Gitee-Github-API%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/NewGiteeOAuthApp.JPG" alt="创建Gitee第三方应用"></p>
<h2 id="2-新建两个java类用来储存获取的Gitee-Github用户信息和获取token所需的参数"><a href="#2-新建两个java类用来储存获取的Gitee-Github用户信息和获取token所需的参数" class="headerlink" title="2.新建两个java类用来储存获取的Gitee/Github用户信息和获取token所需的参数"></a>2.新建两个java类用来储存获取的Gitee/Github用户信息和获取token所需的参数</h2><p>储存Github/Gitee用户信息类，生成get/set方法，我这里为了省空间就不写了</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GithubUser &#123;</span><br><span class="line">    private String name; &#x2F;&#x2F;用户名称</span><br><span class="line">    private String id;	&#x2F;&#x2F;用户ID</span><br><span class="line">    private String bio; &#x2F;&#x2F;用户描述</span><br><span class="line">    private String avatar_url; &#x2F;&#x2F;用户头像地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>储存获取token所需的参数类，生成get/set方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AccessTokenDTO &#123;</span><br><span class="line">    private String client_id;		&#x2F;&#x2F;client_id</span><br><span class="line">    private String client_secret;	&#x2F;&#x2F;client_secret</span><br><span class="line">    private String code;			&#x2F;&#x2F;code码</span><br><span class="line">    private String redirect_uri;	&#x2F;&#x2F;回调地址</span><br><span class="line">    &#x2F;&#x2F;private String state;			&#x2F;&#x2F;Github需要这个参数，Gitee不需要</span><br><span class="line">    private String grant_type;		&#x2F;&#x2F;Github不需要这个参数，Gitee需要</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-导入两个包，方便后续使用"><a href="#3-导入两个包，方便后续使用" class="headerlink" title="3.导入两个包，方便后续使用"></a>3.导入两个包，方便后续使用</h2><p>在pom文件中导入两个包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 方便发送get&#x2F;post请求 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.squareup.okhttp3&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;okhttp&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.14.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- json和String类型快速转换 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.57&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-获取用户信息"><a href="#4-获取用户信息" class="headerlink" title="4.获取用户信息"></a>4.获取用户信息</h2><h3 id="4-1-在需要登录的位置添加链接"><a href="#4-1-在需要登录的位置添加链接" class="headerlink" title="4.1 在需要登录的位置添加链接"></a>4.1 在需要登录的位置添加链接</h3><p>Github地址<code>https://github.com/login/oauth/authorize?client_id=创建应用给的id&amp;redirect_uri=回调地址&amp;scope=user&amp;state=1</code><br>Gitee地址<code>https://gitee.com/oauth/authorize?client_id=创建应用给的id&amp;redirect_uri=回调地址&amp;response_type=code</code></p>
<h3 id="4-2-新建一个控制器类"><a href="#4-2-新建一个控制器类" class="headerlink" title="4.2 新建一个控制器类"></a>4.2 新建一个控制器类</h3><p>发送Git请求获取code码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	@Autowired</span><br><span class="line">    private GithubProvider githubProvider;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthorizeService authorizeService;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;你的clientId&quot;)</span><br><span class="line">    private String clientId;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;你的clientSecret&quot;)</span><br><span class="line">    private String clientSecret;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;你的回调地址&quot;)</span><br><span class="line">    private String redirectUri;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;callback&quot;)</span><br><span class="line">    public String callback(@RequestParam(name &#x3D; &quot;code&quot;) String code,</span><br><span class="line">                           HttpServletResponse response)&#123;&#x2F;&#x2F;@RequestParam(name &#x3D; &quot;state&quot;) String state, Github需要这个参数</span><br><span class="line">        AccessTokenDTO accessTokenDTO &#x3D; new AccessTokenDTO();</span><br><span class="line">        accessTokenDTO.setClient_id(clientId);</span><br><span class="line">        accessTokenDTO.setClient_secret(clientSecret);</span><br><span class="line">        accessTokenDTO.setCode(code);</span><br><span class="line">        accessTokenDTO.setRedirect_uri(redirectUri);</span><br><span class="line">        accessTokenDTO.setGrant_type(&quot;authorization_code&quot;);&#x2F;&#x2F;Gitee需要这个参数</span><br><span class="line">        &#x2F;&#x2F;accessTokenDTO.setState(state); &#x2F;&#x2F;Github需要这个参数</span><br><span class="line">        String accessToken &#x3D; githubProvider.getAccessToken(accessTokenDTO);&#x2F;&#x2F;获取token方法</span><br><span class="line">        GithubUser githubUser &#x3D; githubProvider.getUser(accessToken);	&#x2F;&#x2F;获取User信息方法</span><br><span class="line">        if (githubUser !&#x3D; null &amp;&amp; githubUser.getId() !&#x3D; null)&#123;			&#x2F;&#x2F;如果不为空，插入数据库</span><br><span class="line">            User user &#x3D; new User();</span><br><span class="line">            String token &#x3D; UUID.randomUUID().toString();</span><br><span class="line">            user.setName(githubUser.getName());</span><br><span class="line">            user.setToken(token);</span><br><span class="line">            user.setAccountId(githubUser.getId());</span><br><span class="line">            user.setAvatarUrl(githubUser.getAvatar_url());</span><br><span class="line">            authorizeService.insertUser(user);</span><br><span class="line">            response.addCookie(new Cookie(&quot;token&quot;, token));			&#x2F;&#x2F;添加cookie</span><br><span class="line">            return &quot;redirect:&#x2F;&quot;;									&#x2F;&#x2F;返回主页</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            &#x2F;&#x2F;登录失败，重新登录</span><br><span class="line">            return &quot;redirect:&#x2F;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-新建一个类，写获取token的方法和获取User信息的方法"><a href="#4-3-新建一个类，写获取token的方法和获取User信息的方法" class="headerlink" title="4.3 新建一个类，写获取token的方法和获取User信息的方法"></a>4.3 新建一个类，写获取token的方法和获取User信息的方法</h3><p>携带参数发送POST请求获取token<br>获取token的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String getAccessToken(AccessTokenDTO accessTokenDTO)&#123;</span><br><span class="line">	MediaType mediaType &#x3D; MediaType.get(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">	OkHttpClient client &#x3D; new OkHttpClient();</span><br><span class="line"></span><br><span class="line">	RequestBody body &#x3D; RequestBody.create(mediaType, JSON.toJSONString(accessTokenDTO));</span><br><span class="line">	Request request &#x3D; new Request.Builder()</span><br><span class="line">			.url(&quot;https:&#x2F;&#x2F;gitee.com&#x2F;oauth&#x2F;token&quot;)&#x2F;&#x2F;https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;access_token</span><br><span class="line">			.post(body)</span><br><span class="line">			.build();</span><br><span class="line">	try (Response response &#x3D; client.newCall(request).execute()) &#123;</span><br><span class="line">		String string &#x3D; response.body().string();</span><br><span class="line">		JSONObject jsonObject  &#x3D; JSONObject.parseObject(string); &#x2F;&#x2F;将String转换为json串</span><br><span class="line">		String token &#x3D; jsonObject.getString(&quot;access_token&quot;); &#x2F;&#x2F;获取json串中key为access_token的值</span><br><span class="line">		&#x2F;&#x2F;String token &#x3D; string.split(&quot;&amp;&quot;)[0].split(&quot;&#x3D;&quot;)[1];&#x2F;&#x2F;这里Github和Gitee不同，Github返回的是一个地址，Gitee返回的是json串。</span><br><span class="line">		return token;</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用token获取用户数据<br>获取User信息的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public GithubUser getUser(String accessToken)&#123;</span><br><span class="line">	OkHttpClient client &#x3D; new OkHttpClient();</span><br><span class="line">	Request request &#x3D; new Request.Builder()</span><br><span class="line">			.url(&quot;https:&#x2F;&#x2F;gitee.com&#x2F;api&#x2F;v5&#x2F;user?access_token&#x3D;&quot; + accessToken)&#x2F;&#x2F;https:&#x2F;&#x2F;api.github.com&#x2F;user?access_token&#x3D;</span><br><span class="line">			.build();</span><br><span class="line">	try &#123;</span><br><span class="line">		Response response &#x3D; client.newCall(request).execute();</span><br><span class="line">		String string &#x3D; response.body().string();</span><br><span class="line">		GithubUser githubUser &#x3D; JSON.parseObject(string, GithubUser.class);</span><br><span class="line">		return githubUser;</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是调用Gitee/Github API实现第三方登录流程</p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Github</tag>
        <tag>Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery动态生成的元素绑定事件</title>
    <url>/2020/03/24/jQuery%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%9A%84%E5%85%83%E7%B4%A0%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>前几天写代码的时候遇到一个问题，通过引入的js文件动态生成的元素绑定单击事件不起作用。于是去查找下资料，发现动态生成的元素无法使用click方法绑定。如果需要给动态的元素绑定事件，需要使用到on()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#comment&quot;).on(&quot;click&quot;,&quot;button&quot;,function()&#123;</span><br><span class="line">	&lt;!-- 这里写方法的内容 --&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>on()方法，可以给未来的元素绑定事件<br>使用方法：<br>1、先选中动态生成元素的父元素 如：#comment<br>2、然后绑定事件<br>3、再选中子类                  如：button<br>可以理解为给id为comment的元素下的button元素包括未来的button元素绑定click事件,这是比较通俗易懂的理解，详细内容可以看文档的具体说明</p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>使用js jquery分别获取地址栏参数值</title>
    <url>/2020/03/21/%E4%BD%BF%E7%94%A8js-jquery%E5%88%86%E5%88%AB%E8%8E%B7%E5%8F%96%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%8F%82%E6%95%B0%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="使用JS获取地址栏参数值"><a href="#使用JS获取地址栏参数值" class="headerlink" title="使用JS获取地址栏参数值"></a>使用JS获取地址栏参数值</h2><p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function GetQueryString(name) &#123;</span><br><span class="line">    var reg &#x3D; new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;&#x3D;([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">    var r &#x3D; window.location.search.substr(1).match(reg);</span><br><span class="line">    if(r!&#x3D;null)return  unescape(r[2]); return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>调用方法GetQueryString(“参数名”);<br>方法二:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line">  * 获取指定URL的参数值 </span><br><span class="line">  * @param url  指定的URL地址 </span><br><span class="line">  * @param name 参数名称 </span><br><span class="line">  * @return 参数值 </span><br><span class="line">*&#x2F;  </span><br><span class="line"> function getUrlParam(url,name) &#123;  </span><br><span class="line">     var pattern &#x3D; new RegExp(&quot;[?&amp;]&quot;+name+&quot;\&#x3D;([^&amp;]+)&quot;, &quot;g&quot;);  </span><br><span class="line">     var matcher &#x3D; pattern.exec(url);  </span><br><span class="line">     var items &#x3D; null;  </span><br><span class="line">     if(null !&#x3D; matcher)&#123;  </span><br><span class="line">             try&#123;  </span><br><span class="line">                    items &#x3D; decodeURIComponent(decodeURIComponent(matcher[1]));  </span><br><span class="line">             &#125;catch(e)&#123;  </span><br><span class="line">                     try&#123;  </span><br><span class="line">                             items &#x3D; decodeURIComponent(matcher[1]);  </span><br><span class="line">                     &#125;catch(e)&#123;  </span><br><span class="line">                             items &#x3D; matcher[1];  </span><br><span class="line">                     &#125;  </span><br><span class="line">             &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     return items;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方法getUrlParam(document.href,”参数名”);</p>
<h2 id="使用jQuery获取地址栏参数"><a href="#使用jQuery获取地址栏参数" class="headerlink" title="使用jQuery获取地址栏参数"></a>使用jQuery获取地址栏参数</h2><p>使用下面的方式为jquery扩展一个方法来获取url参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function ($) &#123;</span><br><span class="line">    $.getUrlParam &#x3D; function (name) &#123;</span><br><span class="line">        var reg &#x3D; new RegExp(&quot;(^|&amp;)&quot; + name + &quot;&#x3D;([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">        var r &#x3D; window.location.search.substr(1).match(reg);</span><br><span class="line">        if (r !&#x3D; null) return unescape(r[2]); return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>
<p>调用方法$.getUrlParam(“参数名”);</p>
<p>注意:javascript对参数编码解码方法要一致</p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>jquery</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>简单好用的jquery分页插件</title>
    <url>/2020/03/18/%E7%AE%80%E5%8D%95%E5%A5%BD%E7%94%A8%E7%9A%84jquery%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>昨天写项目的时候要用到分页功能，于是去找了一下jquery分页插件。以前有到一个分页插件，但是样式不太好看。在jquery插件库找到一个简单好用的分页插件，分享一下<a href="http://www.jq22.com/jquery-info22247" target="_blank" rel="noopener">jQuery分页插件</a><br>样式如下</p>
<a id="more"></a>
<p><img src="/2020/03/18/%E7%AE%80%E5%8D%95%E5%A5%BD%E7%94%A8%E7%9A%84jquery%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/jQueryPaging.JPG" alt="jquery分页插件"><br>使用步骤：<br>1.下载解压后，将js和css文件导入项目<br>2.在html页面中找到一个合适的位置插入代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;pagination1&quot; class&#x3D;&quot;page fl&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>3.新建一个js文件，添加js代码，在html中引入js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#pagination1&quot;).pagination(&#123;</span><br><span class="line">                        currentPage: page.pageno, &lt;!-- 当前所在页码 --&gt;</span><br><span class="line">                        totalPage: page.totalno,  &lt;!-- 总页码 --&gt;</span><br><span class="line">                        callback: queryPage		  &lt;!-- 回调函数 --&gt;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure>
<p>刷新页面，生成分页条</p>
]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>外部引入js文件不生效解决方法</title>
    <url>/2020/03/14/%E5%A4%96%E9%83%A8%E5%BC%95%E5%85%A5js%E6%96%87%E4%BB%B6%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天写项目用到js时，本来代码是直接写在<code>&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code>中的，但我想通过外部引入js文件。引入后发现js不生效，于是去找资料。大多数都是说加上<code>window.οnlοad=function(){}</code>将代码放在里面就可以了，但是我试了一下好像不行。最后发现我们需要获取元素时，必须等到该元素被加载完成后才能获取。我们可以把js代码放到该元素的后面，但是这样就会造成js在我们的body中不好管理。所有页面加载完毕后所有的元素已经加载完毕。一般获取元素做操作都要在页面加载完毕后操作。使用<code>$(function(){});</code>可以让页面加载完毕后执行里面的js。于是在js最头部加上<code>$(function(){});</code>，问题解决.</p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>我的博客搭建全过程(1)</title>
    <url>/2020/03/11/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>在开始一切之前<br>    1.1需要一个github账号，没有的话去注册一个；<br>    1.2安装<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a><br>    1.3安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a></p>
<h2 id="2-创建github仓库"><a href="#2-创建github仓库" class="headerlink" title="2.创建github仓库"></a>2.创建github仓库</h2><a id="more"></a>
<p>新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是<a href="http://test.github.io了" target="_blank" rel="noopener">http://test.github.io了</a><br><img src="/2020/03/11/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B/CreateLib.JPG" alt="创建github仓库"><br>因为每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库，我之前已经创建过了。</p>
<h2 id="3-配置SSH-key"><a href="#3-配置SSH-key" class="headerlink" title="3.配置SSH key"></a>3.配置SSH key</h2><p>因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~&#x2F;. ssh #检查本机已存在的ssh密钥</span><br></pre></td></tr></table></figure>
<p>如果提示：No such file or directory 说明你是第一次使用git。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure>
<p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置-&gt;SSH and GPG keys-&gt;New SSH key;将刚复制的内容粘贴到key那里，title随便填，保存。</p>
<h2 id="4-使用hexo搭建个人博客"><a href="#4-使用hexo搭建个人博客" class="headerlink" title="4.使用hexo搭建个人博客"></a>4.使用hexo搭建个人博客</h2><h3 id="4-1安装之前说几个注意事项："><a href="#4-1安装之前说几个注意事项：" class="headerlink" title="4.1安装之前说几个注意事项："></a>4.1安装之前说几个注意事项：</h3><p>1.很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；<br>2.hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个theme下的；</p>
<h3 id="4-2安装hexo"><a href="#4-2安装hexo" class="headerlink" title="4.2安装hexo"></a>4.2安装hexo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="4-3创建博客文件夹"><a href="#4-3创建博客文件夹" class="headerlink" title="4.3创建博客文件夹"></a>4.3创建博客文件夹</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;你的文件夹名字&gt; #如 hexo init thexwen</span><br></pre></td></tr></table></figure>
<p>注意:他会在你命令当前路径下创建一个文件夹，这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p>
<h3 id="4-4初始化文件夹"><a href="#4-4初始化文件夹" class="headerlink" title="4.4初始化文件夹"></a>4.4初始化文件夹</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &lt;folder&gt; #进入你的博客文件夹</span><br><span class="line">$ npm install #初始化文件夹</span><br></pre></td></tr></table></figure>
<p>初始化后，您的项目文件夹将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<h3 id="4-5编写第一篇博客"><a href="#4-5编写第一篇博客" class="headerlink" title="4.5编写第一篇博客"></a>4.5编写第一篇博客</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;你的博客名称&quot;</span><br></pre></td></tr></table></figure>
<p>执行上面命令，在你的…\source_posts下会生产一个.md文件，打开文件就可以编写你的博客</p>
<h3 id="4-6访问你的博客"><a href="#4-6访问你的博客" class="headerlink" title="4.6访问你的博客"></a>4.6访问你的博客</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate #生成静态文件</span><br><span class="line">$ hexo server	#启动本地服务器。默认情况下，该位置为http:&#x2F;&#x2F;localhost:4000&#x2F;</span><br></pre></td></tr></table></figure>
<p>执行上面两条命令，打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到内容，第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑。<br><img src="/2020/03/11/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B/BlogSite.png" alt="博客站点"></p>
<h2 id="5-部署到github"><a href="#5-部署到github" class="headerlink" title="5.部署到github"></a>5.部署到github</h2><p>如果你一切都配置好了，发布上传很容易，一句命令就搞定，当然关键还是你要把所有东西配置好。<br>首先，ssh key肯定要配置好。<br>其次，配置_config.yml中有关deploy的部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">	repo: https:&#x2F;&#x2F;github.com&#x2F;你的github名称&#x2F;你的github名称.github.io.git #如https:&#x2F;&#x2F;github.com&#x2F;TheXWen&#x2F;thexwen.github.io.git</span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>
<p>另外我们还需要额外安装一个支持 Git 的部署插件，名字叫做 hexo-deployer-git，有了它我们才可以顺利将其部署到 GitHub 上面，如果不安装的话，在执行部署命令时会报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deployer not found: git</span><br></pre></td></tr></table></figure>
<p>在项目目录下执行安装命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>安装成功之后，执行部署命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>这时候我们访问一下 GitHub Repository 同名的链接，比如我的 thexwen 博客的 Repository 名称取的是 thexwen.github.io，那我就访问 <a href="http://thexwen.github.io，这时候我们就可以看到跟本地一模一样的博客内容了。" target="_blank" rel="noopener">http://thexwen.github.io，这时候我们就可以看到跟本地一模一样的博客内容了。</a></p>
<h2 id="6-配置站点信息"><a href="#6-配置站点信息" class="headerlink" title="6.配置站点信息"></a>6.配置站点信息</h2><p>完成如上内容之后，实际上我们只完成了博客搭建的一小步，因为我们仅仅是把初始化的页面部署成功了，博客里面还没有设置任何有效的信息.<br>修改根目录下的 _config.yml 文件，找到 Site 区域，这里面可以配置站点标题 title、副标题 subtitle 等内容、关键字 keywords 等内容，比如我的就修改为如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: xw&#39;s Blog #标题</span><br><span class="line">subtitle: 记录,分享 #副标题</span><br><span class="line">description: make an all-out effort #描述</span><br><span class="line">keywords: &quot;java,问题,个人&quot; #关键字</span><br><span class="line">author: xw #作者</span><br><span class="line">language: zh-CN #中文</span><br><span class="line">timezone: &#39;&#39; #时区</span><br></pre></td></tr></table></figure>
<p>以上就是从零简单搭建一个 Hexo 博客的流程，希望对大家有帮助。</p>
]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一台阿里服务器</title>
    <url>/2020/03/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8F%B0%E9%98%BF%E9%87%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>前段时间一直想买一台阿里的服务器，但是没有碰到活动。昨天上去看看发现阿里在搞活动，<img src="/2020/03/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8F%B0%E9%98%BF%E9%87%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/19-03-11-aly.JPG" alt="阿里云活动"><br>果断入手一台，哈哈。本来是想用来搭建博客的，但是想着马上要找实习了，博客也没什么东西，就算了。还是拿来挂项目吧</p>
]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/03/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这是我的第一篇博客</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/10/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>

<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
